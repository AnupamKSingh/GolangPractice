// Code generated by protoc-gen-go.
// source: new1.proto
// DO NOT EDIT!

/*
Package new1 is a generated protocol buffer package.

It is generated from these files:
	new1.proto

It has these top-level messages:
	EnumMessage
	Message
*/
package new1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EnumMessage_Enum int32

const (
	EnumMessage_ANU EnumMessage_Enum = 0
	EnumMessage_DEE EnumMessage_Enum = 1
)

var EnumMessage_Enum_name = map[int32]string{
	0: "ANU",
	1: "DEE",
}
var EnumMessage_Enum_value = map[string]int32{
	"ANU": 0,
	"DEE": 1,
}

func (x EnumMessage_Enum) String() string {
	return proto.EnumName(EnumMessage_Enum_name, int32(x))
}
func (EnumMessage_Enum) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type EnumMessage struct {
	A EnumMessage_Enum `protobuf:"varint,1,opt,name=a,enum=new1.EnumMessage_Enum" json:"a,omitempty"`
}

func (m *EnumMessage) Reset()                    { *m = EnumMessage{} }
func (m *EnumMessage) String() string            { return proto.CompactTextString(m) }
func (*EnumMessage) ProtoMessage()               {}
func (*EnumMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EnumMessage) GetA() EnumMessage_Enum {
	if m != nil {
		return m.A
	}
	return EnumMessage_ANU
}

type Message struct {
	A uint64       `protobuf:"varint,1,opt,name=a" json:"a,omitempty"`
	B uint32       `protobuf:"varint,2,opt,name=b" json:"b,omitempty"`
	C float64      `protobuf:"fixed64,3,opt,name=c" json:"c,omitempty"`
	D string       `protobuf:"bytes,4,opt,name=d" json:"d,omitempty"`
	E []bool       `protobuf:"varint,5,rep,packed,name=e" json:"e,omitempty"`
	F *EnumMessage `protobuf:"bytes,6,opt,name=f" json:"f,omitempty"`
	G []byte       `protobuf:"bytes,7,opt,name=g,proto3" json:"g,omitempty"`
	H []string     `protobuf:"bytes,8,rep,name=h" json:"h,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Message) GetA() uint64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *Message) GetB() uint32 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *Message) GetC() float64 {
	if m != nil {
		return m.C
	}
	return 0
}

func (m *Message) GetD() string {
	if m != nil {
		return m.D
	}
	return ""
}

func (m *Message) GetE() []bool {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *Message) GetF() *EnumMessage {
	if m != nil {
		return m.F
	}
	return nil
}

func (m *Message) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *Message) GetH() []string {
	if m != nil {
		return m.H
	}
	return nil
}

func init() {
	proto.RegisterType((*EnumMessage)(nil), "new1.EnumMessage")
	proto.RegisterType((*Message)(nil), "new1.Message")
	proto.RegisterEnum("new1.EnumMessage_Enum", EnumMessage_Enum_name, EnumMessage_Enum_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for New1 service

type New1Client interface {
	ServertoClient(ctx context.Context, opts ...grpc.CallOption) (New1_ServertoClientClient, error)
}

type new1Client struct {
	cc *grpc.ClientConn
}

func NewNew1Client(cc *grpc.ClientConn) New1Client {
	return &new1Client{cc}
}

func (c *new1Client) ServertoClient(ctx context.Context, opts ...grpc.CallOption) (New1_ServertoClientClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_New1_serviceDesc.Streams[0], c.cc, "/new1.new1/ServertoClient", opts...)
	if err != nil {
		return nil, err
	}
	x := &new1ServertoClientClient{stream}
	return x, nil
}

type New1_ServertoClientClient interface {
	Send(*Message) error
	Recv() (*Message, error)
	grpc.ClientStream
}

type new1ServertoClientClient struct {
	grpc.ClientStream
}

func (x *new1ServertoClientClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *new1ServertoClientClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for New1 service

type New1Server interface {
	ServertoClient(New1_ServertoClientServer) error
}

func RegisterNew1Server(s *grpc.Server, srv New1Server) {
	s.RegisterService(&_New1_serviceDesc, srv)
}

func _New1_ServertoClient_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(New1Server).ServertoClient(&new1ServertoClientServer{stream})
}

type New1_ServertoClientServer interface {
	Send(*Message) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type new1ServertoClientServer struct {
	grpc.ServerStream
}

func (x *new1ServertoClientServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *new1ServertoClientServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _New1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "new1.new1",
	HandlerType: (*New1Server)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServertoClient",
			Handler:       _New1_ServertoClient_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "new1.proto",
}

func init() { proto.RegisterFile("new1.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x90, 0xcd, 0x4a, 0xc3, 0x40,
	0x14, 0x46, 0xfb, 0x99, 0xd8, 0xd6, 0xe9, 0x0f, 0x75, 0x16, 0x32, 0xe8, 0xc2, 0x21, 0x28, 0xcc,
	0x2a, 0x68, 0x74, 0xe9, 0xc6, 0x6a, 0x96, 0x15, 0x19, 0xf1, 0x01, 0x92, 0xf4, 0x36, 0x2d, 0xb4,
	0x49, 0x48, 0xe2, 0xcf, 0x43, 0xf8, 0xd0, 0x72, 0x27, 0x16, 0x14, 0x77, 0xe7, 0x30, 0xf7, 0x1e,
	0x66, 0x46, 0x88, 0x82, 0x3e, 0xae, 0xc3, 0xaa, 0x2e, 0xdb, 0x52, 0xfa, 0xcc, 0xc1, 0x42, 0x8c,
	0xe2, 0xe2, 0x6d, 0xb7, 0xa0, 0xa6, 0x49, 0x72, 0x92, 0x17, 0x02, 0x89, 0x82, 0x86, 0x99, 0x46,
	0x27, 0xa1, 0x1b, 0xfe, 0x75, 0xea, 0xd8, 0x22, 0x09, 0x94, 0xf0, 0x19, 0xe5, 0x40, 0x78, 0xf7,
	0x4f, 0xaf, 0xb3, 0x1e, 0xc3, 0x63, 0x1c, 0xcf, 0x10, 0x7c, 0x41, 0x0c, 0xf6, 0xad, 0xf1, 0xbe,
	0xe5, 0x5b, 0x24, 0x6c, 0xa9, 0x3a, 0xd0, 0x30, 0x13, 0x8b, 0x94, 0x2d, 0x53, 0x9e, 0x86, 0x81,
	0x45, 0xc6, 0xb6, 0x54, 0xbe, 0x86, 0x39, 0xb2, 0x58, 0xb2, 0x91, 0x3a, 0xd4, 0x9e, 0x19, 0x5a,
	0x90, 0x3c, 0x17, 0x58, 0xa9, 0xbe, 0x86, 0x19, 0x45, 0xc7, 0xff, 0x6e, 0x64, 0xb1, 0xe2, 0xf1,
	0x5c, 0x0d, 0x34, 0xcc, 0xd8, 0x22, 0x67, 0x5b, 0xab, 0xa1, 0xf6, 0x38, 0xb5, 0x8e, 0xee, 0x84,
	0x7b, 0xa5, 0xbc, 0x15, 0xd3, 0x17, 0xaa, 0xdf, 0xa9, 0x6e, 0xcb, 0x87, 0xed, 0x86, 0x8a, 0x56,
	0x4e, 0xba, 0xd6, 0x4f, 0xe7, 0xf4, 0xaf, 0x06, 0x3d, 0x83, 0x2b, 0xcc, 0x2f, 0xbb, 0xed, 0xf9,
	0xd9, 0xa6, 0x0c, 0xf3, 0xba, 0xca, 0x42, 0xfa, 0x4c, 0x76, 0xd5, 0x96, 0x9a, 0xee, 0x07, 0xdd,
	0xca, 0x33, 0xd2, 0xbe, 0xb3, 0x9b, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfb, 0xf2, 0xec, 0x9e,
	0x5d, 0x01, 0x00, 0x00,
}
